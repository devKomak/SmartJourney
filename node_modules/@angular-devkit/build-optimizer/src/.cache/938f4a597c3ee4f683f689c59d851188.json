{"remainingRequest":"C:\\Users\\Jacek\\Desktop\\SmartJourney\\SmartJourney\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Users\\Jacek\\Desktop\\SmartJourney\\SmartJourney\\node_modules\\@firebase\\database\\dist\\cjs\\src\\core\\util\\validation.js","dependencies":[{"path":"C:\\Users\\Jacek\\Desktop\\SmartJourney\\SmartJourney\\node_modules\\@firebase\\database\\dist\\cjs\\src\\core\\util\\validation.js","mtime":1524401691710},{"path":"C:\\Users\\Jacek\\Desktop\\SmartJourney\\SmartJourney\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1524401694898},{"path":"C:\\Users\\Jacek\\Desktop\\SmartJourney\\SmartJourney\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1524401688360}],"contextDependencies":[],"result":["\"use strict\";\r\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Path_1 = require(\"./Path\");\r\nvar util_1 = require(\"@firebase/util\");\r\nvar util_2 = require(\"./util\");\r\nvar util_3 = require(\"@firebase/util\");\r\nvar util_4 = require(\"@firebase/util\");\r\n/**\r\n * True for invalid Firebase keys\r\n * @type {RegExp}\r\n * @private\r\n */\r\nexports.INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\r\n/**\r\n * True for invalid Firebase paths.\r\n * Allows '/' in paths.\r\n * @type {RegExp}\r\n * @private\r\n */\r\nexports.INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\r\n/**\r\n * Maximum number of characters to allow in leaf value\r\n * @type {number}\r\n * @private\r\n */\r\nexports.MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\r\n/**\r\n * @param {*} key\r\n * @return {boolean}\r\n */\r\nexports.isValidKey = function (key) {\r\n    return (typeof key === 'string' && key.length !== 0 && !exports.INVALID_KEY_REGEX_.test(key));\r\n};\r\n/**\r\n * @param {string} pathString\r\n * @return {boolean}\r\n */\r\nexports.isValidPathString = function (pathString) {\r\n    return (typeof pathString === 'string' &&\r\n        pathString.length !== 0 &&\r\n        !exports.INVALID_PATH_REGEX_.test(pathString));\r\n};\r\n/**\r\n * @param {string} pathString\r\n * @return {boolean}\r\n */\r\nexports.isValidRootPathString = function (pathString) {\r\n    if (pathString) {\r\n        // Allow '/.info/' at the beginning.\r\n        pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\r\n    }\r\n    return exports.isValidPathString(pathString);\r\n};\r\n/**\r\n * @param {*} priority\r\n * @return {boolean}\r\n */\r\nexports.isValidPriority = function (priority) {\r\n    return (priority === null ||\r\n        typeof priority === 'string' ||\r\n        (typeof priority === 'number' && !util_2.isInvalidJSONNumber(priority)) ||\r\n        (priority && typeof priority === 'object' && util_1.contains(priority, '.sv')));\r\n};\r\n/**\r\n * Pre-validate a datum passed as an argument to Firebase function.\r\n *\r\n * @param {string} fnName\r\n * @param {number} argumentNumber\r\n * @param {*} data\r\n * @param {!Path} path\r\n * @param {boolean} optional\r\n */\r\nexports.validateFirebaseDataArg = function (fnName, argumentNumber, data, path, optional) {\r\n    if (optional && data === undefined)\r\n        return;\r\n    exports.validateFirebaseData(util_3.errorPrefix(fnName, argumentNumber, optional), data, path);\r\n};\r\n/**\r\n * Validate a data object client-side before sending to server.\r\n *\r\n * @param {string} errorPrefix\r\n * @param {*} data\r\n * @param {!Path|!ValidationPath} path_\r\n */\r\nexports.validateFirebaseData = function (errorPrefix, data, path_) {\r\n    var path = path_ instanceof Path_1.Path ? new Path_1.ValidationPath(path_, errorPrefix) : path_;\r\n    if (data === undefined) {\r\n        throw new Error(errorPrefix + 'contains undefined ' + path.toErrorString());\r\n    }\r\n    if (typeof data === 'function') {\r\n        throw new Error(errorPrefix +\r\n            'contains a function ' +\r\n            path.toErrorString() +\r\n            ' with contents = ' +\r\n            data.toString());\r\n    }\r\n    if (util_2.isInvalidJSONNumber(data)) {\r\n        throw new Error(errorPrefix + 'contains ' + data.toString() + ' ' + path.toErrorString());\r\n    }\r\n    // Check max leaf size, but try to avoid the utf8 conversion if we can.\r\n    if (typeof data === 'string' &&\r\n        data.length > exports.MAX_LEAF_SIZE_ / 3 &&\r\n        util_4.stringLength(data) > exports.MAX_LEAF_SIZE_) {\r\n        throw new Error(errorPrefix +\r\n            'contains a string greater than ' +\r\n            exports.MAX_LEAF_SIZE_ +\r\n            ' utf8 bytes ' +\r\n            path.toErrorString() +\r\n            \" ('\" +\r\n            data.substring(0, 50) +\r\n            \"...')\");\r\n    }\r\n    // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\r\n    // to save extra walking of large objects.\r\n    if (data && typeof data === 'object') {\r\n        var hasDotValue_1 = false, hasActualChild_1 = false;\r\n        util_1.forEach(data, function (key, value) {\r\n            if (key === '.value') {\r\n                hasDotValue_1 = true;\r\n            }\r\n            else if (key !== '.priority' && key !== '.sv') {\r\n                hasActualChild_1 = true;\r\n                if (!exports.isValidKey(key)) {\r\n                    throw new Error(errorPrefix +\r\n                        ' contains an invalid key (' +\r\n                        key +\r\n                        ') ' +\r\n                        path.toErrorString() +\r\n                        '.  Keys must be non-empty strings ' +\r\n                        'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\r\n                }\r\n            }\r\n            path.push(key);\r\n            exports.validateFirebaseData(errorPrefix, value, path);\r\n            path.pop();\r\n        });\r\n        if (hasDotValue_1 && hasActualChild_1) {\r\n            throw new Error(errorPrefix +\r\n                ' contains \".value\" child ' +\r\n                path.toErrorString() +\r\n                ' in addition to actual children.');\r\n        }\r\n    }\r\n};\r\n/**\r\n * Pre-validate paths passed in the firebase function.\r\n *\r\n * @param {string} errorPrefix\r\n * @param {Array<!Path>} mergePaths\r\n */\r\nexports.validateFirebaseMergePaths = function (errorPrefix, mergePaths) {\r\n    var i, curPath;\r\n    for (i = 0; i < mergePaths.length; i++) {\r\n        curPath = mergePaths[i];\r\n        var keys = curPath.slice();\r\n        for (var j = 0; j < keys.length; j++) {\r\n            if (keys[j] === '.priority' && j === keys.length - 1) {\r\n                // .priority is OK\r\n            }\r\n            else if (!exports.isValidKey(keys[j])) {\r\n                throw new Error(errorPrefix +\r\n                    'contains an invalid key (' +\r\n                    keys[j] +\r\n                    ') in path ' +\r\n                    curPath.toString() +\r\n                    '. Keys must be non-empty strings ' +\r\n                    'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\r\n            }\r\n        }\r\n    }\r\n    // Check that update keys are not descendants of each other.\r\n    // We rely on the property that sorting guarantees that ancestors come\r\n    // right before descendants.\r\n    mergePaths.sort(Path_1.Path.comparePaths);\r\n    var prevPath = null;\r\n    for (i = 0; i < mergePaths.length; i++) {\r\n        curPath = mergePaths[i];\r\n        if (prevPath !== null && prevPath.contains(curPath)) {\r\n            throw new Error(errorPrefix +\r\n                'contains a path ' +\r\n                prevPath.toString() +\r\n                ' that is ancestor of another path ' +\r\n                curPath.toString());\r\n        }\r\n        prevPath = curPath;\r\n    }\r\n};\r\n/**\r\n * pre-validate an object passed as an argument to firebase function (\r\n * must be an object - e.g. for firebase.update()).\r\n *\r\n * @param {string} fnName\r\n * @param {number} argumentNumber\r\n * @param {*} data\r\n * @param {!Path} path\r\n * @param {boolean} optional\r\n */\r\nexports.validateFirebaseMergeDataArg = function (fnName, argumentNumber, data, path, optional) {\r\n    if (optional && data === undefined)\r\n        return;\r\n    var errorPrefix = util_3.errorPrefix(fnName, argumentNumber, optional);\r\n    if (!(data && typeof data === 'object') || Array.isArray(data)) {\r\n        throw new Error(errorPrefix + ' must be an object containing the children to replace.');\r\n    }\r\n    var mergePaths = [];\r\n    util_1.forEach(data, function (key, value) {\r\n        var curPath = new Path_1.Path(key);\r\n        exports.validateFirebaseData(errorPrefix, value, path.child(curPath));\r\n        if (curPath.getBack() === '.priority') {\r\n            if (!exports.isValidPriority(value)) {\r\n                throw new Error(errorPrefix +\r\n                    \"contains an invalid value for '\" +\r\n                    curPath.toString() +\r\n                    \"', which must be a valid \" +\r\n                    'Firebase priority (a string, finite number, server value, or null).');\r\n            }\r\n        }\r\n        mergePaths.push(curPath);\r\n    });\r\n    exports.validateFirebaseMergePaths(errorPrefix, mergePaths);\r\n};\r\nexports.validatePriority = function (fnName, argumentNumber, priority, optional) {\r\n    if (optional && priority === undefined)\r\n        return;\r\n    if (util_2.isInvalidJSONNumber(priority))\r\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +\r\n            'is ' +\r\n            priority.toString() +\r\n            ', but must be a valid Firebase priority (a string, finite number, ' +\r\n            'server value, or null).');\r\n    // Special case to allow importing data with a .sv.\r\n    if (!exports.isValidPriority(priority))\r\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +\r\n            'must be a valid Firebase priority ' +\r\n            '(a string, finite number, server value, or null).');\r\n};\r\nexports.validateEventType = function (fnName, argumentNumber, eventType, optional) {\r\n    if (optional && eventType === undefined)\r\n        return;\r\n    switch (eventType) {\r\n        case 'value':\r\n        case 'child_added':\r\n        case 'child_removed':\r\n        case 'child_changed':\r\n        case 'child_moved':\r\n            break;\r\n        default:\r\n            throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +\r\n                'must be a valid event type = \"value\", \"child_added\", \"child_removed\", ' +\r\n                '\"child_changed\", or \"child_moved\".');\r\n    }\r\n};\r\nexports.validateKey = function (fnName, argumentNumber, key, optional) {\r\n    if (optional && key === undefined)\r\n        return;\r\n    if (!exports.isValidKey(key))\r\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +\r\n            'was an invalid key = \"' +\r\n            key +\r\n            '\".  Firebase keys must be non-empty strings and ' +\r\n            'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").');\r\n};\r\nexports.validatePathString = function (fnName, argumentNumber, pathString, optional) {\r\n    if (optional && pathString === undefined)\r\n        return;\r\n    if (!exports.isValidPathString(pathString))\r\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +\r\n            'was an invalid path = \"' +\r\n            pathString +\r\n            '\". Paths must be non-empty strings and ' +\r\n            'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"');\r\n};\r\nexports.validateRootPathString = function (fnName, argumentNumber, pathString, optional) {\r\n    if (pathString) {\r\n        // Allow '/.info/' at the beginning.\r\n        pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\r\n    }\r\n    exports.validatePathString(fnName, argumentNumber, pathString, optional);\r\n};\r\nexports.validateWritablePath = function (fnName, path) {\r\n    if (path.getFront() === '.info') {\r\n        throw new Error(fnName + \" failed = Can't modify data under /.info/\");\r\n    }\r\n};\r\nexports.validateUrl = function (fnName, argumentNumber, parsedUrl) {\r\n    // TODO = Validate server better.\r\n    var pathString = parsedUrl.path.toString();\r\n    if (!(typeof parsedUrl.repoInfo.host === 'string') ||\r\n        parsedUrl.repoInfo.host.length === 0 ||\r\n        (!exports.isValidKey(parsedUrl.repoInfo.namespace) &&\r\n            parsedUrl.repoInfo.host.split(':')[0] !== 'localhost') ||\r\n        (pathString.length !== 0 && !exports.isValidRootPathString(pathString))) {\r\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, false) +\r\n            'must be a valid firebase URL and ' +\r\n            'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".');\r\n    }\r\n};\r\nexports.validateCredential = function (fnName, argumentNumber, cred, optional) {\r\n    if (optional && cred === undefined)\r\n        return;\r\n    if (!(typeof cred === 'string'))\r\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +\r\n            'must be a valid credential (a string).');\r\n};\r\nexports.validateBoolean = function (fnName, argumentNumber, bool, optional) {\r\n    if (optional && bool === undefined)\r\n        return;\r\n    if (typeof bool !== 'boolean')\r\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a boolean.');\r\n};\r\nexports.validateString = function (fnName, argumentNumber, string, optional) {\r\n    if (optional && string === undefined)\r\n        return;\r\n    if (!(typeof string === 'string')) {\r\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +\r\n            'must be a valid string.');\r\n    }\r\n};\r\nexports.validateObject = function (fnName, argumentNumber, obj, optional) {\r\n    if (optional && obj === undefined)\r\n        return;\r\n    if (!(obj && typeof obj === 'object') || obj === null) {\r\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +\r\n            'must be a valid object.');\r\n    }\r\n};\r\nexports.validateObjectContainsKey = function (fnName, argumentNumber, obj, key, optional, opt_type) {\r\n    var objectContainsKey = obj && typeof obj === 'object' && util_1.contains(obj, key);\r\n    if (!objectContainsKey) {\r\n        if (optional) {\r\n            return;\r\n        }\r\n        else {\r\n            throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +\r\n                'must contain the key \"' +\r\n                key +\r\n                '\"');\r\n        }\r\n    }\r\n    if (opt_type) {\r\n        var val = util_1.safeGet(obj, key);\r\n        if ((opt_type === 'number' && !(typeof val === 'number')) ||\r\n            (opt_type === 'string' && !(typeof val === 'string')) ||\r\n            (opt_type === 'boolean' && !(typeof val === 'boolean')) ||\r\n            (opt_type === 'function' && !(typeof val === 'function')) ||\r\n            (opt_type === 'object' && !(typeof val === 'object') && val)) {\r\n            if (optional) {\r\n                throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +\r\n                    'contains invalid value for key \"' +\r\n                    key +\r\n                    '\" (must be of type \"' +\r\n                    opt_type +\r\n                    '\")');\r\n            }\r\n            else {\r\n                throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +\r\n                    'must contain the key \"' +\r\n                    key +\r\n                    '\" with type \"' +\r\n                    opt_type +\r\n                    '\"');\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n//# sourceMappingURL=validation.js.map\r\n",null]}